{% extends "base.html" %}

{% block title %}LED Grid Dashboard{% endblock %}

{% block content %}
<div class="row mb-4">
    <div class="col-lg-4 mb-4 mb-lg-0 order-1 order-lg-2">
        <div class="sticky-preview">
            <div class="card mb-3">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0"><i class="fas fa-tv"></i> Live Preview</h5>
                    <div class="btn-group btn-group-sm" role="group">
                        <button class="btn btn-outline-secondary" data-bs-toggle="collapse" data-bs-target="#previewCollapse" aria-expanded="true" aria-controls="previewCollapse">
                            <i class="fas fa-chevron-up"></i>
                        </button>
                        <button type="button" class="btn btn-outline-secondary" id="toggleRenderer" onclick="toggleRenderer()">
                            <i class="fas fa-eye"></i>
                        </button>
                        <button type="button" class="btn btn-outline-secondary" onclick="resetRenderer()">
                            <i class="fas fa-sync"></i>
                        </button>
                        <button type="button" class="btn btn-outline-primary" id="previewToggle" onclick="togglePreviewMode()">
                            <i class="fas fa-search"></i> <span id="previewToggleText">Preview Mode</span>
                        </button>
                    </div>
                </div>
                <div id="previewCollapse" class="collapse show">
                    <div class="card-body" id="rendererContainer">
                        <div id="animationRenderer" class="text-center">
                            <canvas id="ledCanvas" width="315" height="630" class="led-preview preview-canvas" style="border: 1px solid #ddd; border-radius: 8px; cursor: pointer;"></canvas>
                            <div class="mt-2">
                                <small class="text-muted d-block mb-1">
                                    Canvas rotated to match the physical panel. Click to punch a random hole instantly.
                                </small>
                                <small class="text-muted">
                                    <span id="rendererStatus">Waiting for animation...</span> |
                                    <span id="rendererFPS">0 FPS</span> |
                                    <span id="rendererFrameCount">0 frames</span>
                                </small>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card mb-3">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0"><i class="fas fa-tint"></i> Scene Stats</h5>
                    <div class="btn-group btn-group-sm" role="group">
                        <button class="btn btn-outline-secondary" data-bs-toggle="collapse" data-bs-target="#statsCollapse" aria-expanded="true" aria-controls="statsCollapse">
                            <i class="fas fa-chevron-up"></i>
                        </button>
                        <button class="btn btn-outline-danger" onclick="requestRandomHole()">
                            <i class="fas fa-bolt"></i>
                        </button>
                    </div>
                </div>
                <div id="statsCollapse" class="collapse show">
                    <div class="card-body small">
                        <div class="d-flex justify-content-between align-items-center border-bottom pb-2 mb-2">
                            <span>Fill Level</span>
                            <strong id="statFill">--</strong>
                        </div>
                        <div class="d-flex justify-content-between align-items-center border-bottom pb-2 mb-2">
                            <span>Expected Level</span>
                            <strong id="statExpected">--</strong>
                        </div>
                        <div class="d-flex justify-content-between align-items-center border-bottom pb-2 mb-2">
                            <span>Hole Active</span>
                            <strong id="statHole">--</strong>
                        </div>
                        <div class="d-flex justify-content-between align-items-center border-bottom pb-2 mb-2">
                            <span>Bubbles (peak rise)</span>
                            <strong id="statBubbles">--</strong>
                        </div>
                        <div class="d-flex justify-content-between align-items-center border-bottom pb-2 mb-2">
                            <span>Spray Particles</span>
                            <strong id="statSpray">--</strong>
                        </div>
                        <div class="d-flex justify-content-between align-items-center border-bottom pb-2 mb-2">
                            <span>Spawn Allowed</span>
                            <strong id="statSpawnAllowed">--</strong>
                        </div>
                        <div class="d-flex justify-content-between align-items-center">
                            <span>Animation Hash</span>
                            <code id="statHash">--</code>
                        </div>
                        <small class="text-muted d-block mt-2">
                            Stats update from <code>/api/status</code> so sims + hardware stay in sync.
                        </small>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="mb-0"><i class="fas fa-info-circle"></i> System Status</h5>
                    <div class="btn-group btn-group-sm" role="group">
                        <button class="btn btn-outline-secondary" data-bs-toggle="collapse" data-bs-target="#systemCollapse" aria-expanded="true" aria-controls="systemCollapse">
                            <i class="fas fa-chevron-up"></i>
                        </button>
                    </div>
                </div>
                <div id="systemCollapse" class="collapse show">
                    <div class="card-body">
                        <div class="mb-2">
                            <strong>Animation:</strong><br>
                            <span class="status-indicator {{ 'status-running' if status.is_running else 'status-stopped' }}"></span>
                            <span class="status-text">
                                {% if status.is_running %}
                                    Running: {{ status.current_animation }}
                                {% else %}
                                    Stopped
                                {% endif %}
                            </span>
                        </div>
                        <div class="mb-2">
                            <strong>Performance:</strong><br>
                            <span class="fps-display">{{ "%.1f"|format(status.actual_fps) }} FPS</span>
                            <small class="text-muted">(Target: {{ status.target_fps }} FPS)</small>
                        </div>
                        <div class="mb-2">
                            <strong>LED Configuration:</strong><br>
                            {{ status.led_info.strip_count }} strips × {{ status.led_info.leds_per_strip }} LEDs
                        </div>
                        {% if status.is_running %}
                        <div class="mb-2">
                            <strong>Runtime:</strong><br>
                            {{ "%.1f"|format(status.uptime) }}s
                            <small class="text-muted">({{ status.frame_count }} frames)</small>
                        </div>
                        {% endif %}
                        <div class="d-grid gap-2">
                            {% if status.is_running %}
                            <button class="btn btn-danger" onclick="stopAnimation()">
                                <i class="fas fa-stop"></i> Stop Animation
                            </button>
                            {% endif %}
                            <button class="btn btn-outline-secondary" onclick="refreshPlugins()">
                                <i class="fas fa-sync"></i> Refresh Plugins
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="col-lg-8 order-2 order-lg-1">
        <div class="card">
            <div class="card-header pb-0">
                <ul class="nav nav-tabs card-header-tabs" id="dashboardTabs" role="tablist">
                    <li class="nav-item" role="presentation">
                        <button class="nav-link active" id="tab-animations-link" data-bs-toggle="tab" data-bs-target="#tab-animations" type="button" role="tab">Animations</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="tab-controls-link" data-bs-toggle="tab" data-bs-target="#tab-controls" type="button" role="tab">Controls</button>
                    </li>
                    <li class="nav-item" role="presentation">
                        <button class="nav-link" id="tab-status-link" data-bs-toggle="tab" data-bs-target="#tab-status" type="button" role="tab">Status JSON</button>
                    </li>
                </ul>
            </div>
            <div class="card-body tab-content">
                <div class="tab-pane fade show active" id="tab-animations" role="tabpanel">
                    <div class="row">
                        {% for animation in animations %}
                        <div class="col-md-6 mb-3">
                            <div class="card animation-card h-100">
                                <div class="card-body">
                                    <h5 class="card-title">
                                        <i class="fas fa-play-circle text-primary"></i>
                                        {{ animation.name }}
                                    </h5>
                                    <p class="card-text">{{ animation.description }}</p>
                                    <small class="text-muted">
                                        <i class="fas fa-user"></i> {{ animation.author }}
                                        <span class="ms-2"><i class="fas fa-tag"></i> v{{ animation.version }}</span>
                                    </small>
                                    <div class="mt-3 d-flex gap-2">
                                        <button class="btn btn-outline-primary btn-sm" onclick="previewAnimation('{{ animation.plugin_name }}')">
                                            <i class="fas fa-eye"></i> Preview
                                        </button>
                                        <button class="btn btn-primary btn-sm" onclick="startAnimation('{{ animation.plugin_name }}')">
                                            <i class="fas fa-play"></i> Start
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                        {% endfor %}
                    </div>
                    {% if not animations %}
                    <div class="alert alert-warning">
                        <i class="fas fa-exclamation-triangle"></i>
                        No animations found. Upload some animation plugins to get started!
                    </div>
                    {% endif %}
                </div>
                <div class="tab-pane fade" id="tab-controls" role="tabpanel">
                    <div class="mb-3">
                        <h5 class="fw-semibold">Select Animation</h5>
                        <div class="row">
                            {% for animation in animations %}
                            <div class="col-md-6 mb-2">
                                <button class="btn btn-outline-primary w-100 control-animation-btn" 
                                        data-animation="{{ animation.plugin_name }}"
                                        onclick="selectControlAnimation('{{ animation.plugin_name }}')">
                                    {{ animation.name }}
                                </button>
                            </div>
                            {% endfor %}
                        </div>
                        <div class="mt-2">
                            <button class="btn btn-danger btn-sm" onclick="stopAnimation()">
                                <i class="fas fa-stop"></i> Stop Animation
                            </button>
                        </div>
                    </div>
                    <div class="card mt-3" id="controlParametersCard" style="display: none;">
                        <div class="card-header">
                            <h6 class="mb-0">Animation Parameters</h6>
                            <small class="text-muted">Adjust values to steer the scene in real-time.</small>
                        </div>
                        <div class="card-body" id="controlParametersContainer"></div>
                    </div>
                    <div class="alert alert-info mt-3" id="controlParametersPlaceholder">
                        Start or select an animation to adjust its live controls.
                    </div>
                </div>
                <div class="tab-pane fade" id="tab-status" role="tabpanel">
                    <div class="d-flex justify-content-between align-items-center mb-2">
                        <div>
                            <h6 class="mb-0">Live Status Payload</h6>
                            <small class="text-muted">Data pulled from <code>/api/status</code></small>
                        </div>
                        <button class="btn btn-sm btn-outline-secondary" onclick="copyStatusJson()">
                            <i class="fas fa-copy"></i> Copy
                        </button>
                    </div>
                    <pre id="statusJson" class="bg-dark text-white p-3 rounded" style="max-height: 400px; overflow:auto;">Loading...</pre>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    const INITIAL_STRIP_COUNT = {{ status.led_info.strip_count | default(8) }};
    const INITIAL_LEDS_PER_STRIP = {{ status.led_info.leds_per_strip | default(140) }};
    const INITIAL_STATUS = {{ status | tojson }};

    // Animation Renderer
    class LEDAnimationRenderer {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            this.isRunning = false;
            this.frameCount = 0;
            this.lastFrameTime = 0;
            this.fps = 0;

            // Preview mode settings
            this.previewMode = false;
            this.previewAnimation = null;
            this.fpsCounter = 0;
            this.lastFpsTime = Date.now();
            this.fetchIntervalMs = 150;   // Limit backend polling to ~6-7 FPS
            this.renderTimer = null;
            this.fetchInFlight = false;
            this.lastFrameData = null;
            this.previewParams = null;

            // LED configuration - will be updated from server
            this.stripCount = INITIAL_STRIP_COUNT;
            this.ledsPerStrip = INITIAL_LEDS_PER_STRIP;
            this.totalLeds = this.stripCount * this.ledsPerStrip;

            // Rendering configuration
            this.ledSize = 6;
            this.ledSpacing = 0.5;
            this.stripSpacing = 1;
            this.canvas.addEventListener('click', () => requestRandomHole());

            this.setupCanvas();
            this.startRendering();
        }

        setupCanvas() {
            // Calculate canvas dimensions based on rotated LED layout (strips run horizontally)
            const totalWidth = this.stripCount * (this.ledSize + this.stripSpacing);
            const totalHeight = this.ledsPerStrip * (this.ledSize + this.ledSpacing);

            this.canvas.width = Math.min(totalWidth * 6, 900);
            this.canvas.height = Math.min(totalHeight * 4, 900);

            // Scale LEDs to fit canvas
            this.scaleX = this.canvas.width / totalWidth;
            this.scaleY = this.canvas.height / totalHeight;
            this.scale = Math.min(this.scaleX, this.scaleY);

            this.actualLedSize = Math.max(1, this.ledSize * this.scale);
            this.actualLedSpacing = this.ledSpacing * this.scale;
            this.actualStripSpacing = this.stripSpacing * this.scale;
        }

        async fetchFrameData() {
            try {
                if (this.previewMode && this.previewAnimation) {
                    // In preview mode, fetch preview data for specific animation
                    const hasParams = this.previewParams && Object.keys(this.previewParams).length > 0;
                    const url = hasParams
                        ? `/api/preview/${this.previewAnimation}/with_params`
                        : `/api/preview/${this.previewAnimation}`;
                    const options = hasParams ? {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify(this.previewParams)
                    } : undefined;
                    const response = await fetch(url, options);
                    const data = await response.json();
                    return data;
                } else {
                    // Normal mode - fetch current running animation
                    const response = await fetch('/api/frame');
                    const data = await response.json();
                    return data;
                }
            } catch (error) {
                console.error('Error fetching frame data:', error);
                return null;
            }
        }

        setPreviewAnimation(animationName, params = null) {
            this.previewAnimation = animationName;
            this.setPreviewParams(params);
            console.log(`Preview animation set to: ${animationName}`);
        }

        setPreviewParams(params = null) {
            if (params && typeof params === 'object') {
                this.previewParams = {...params};
            } else {
                this.previewParams = null;
            }
        }

        togglePreviewMode() {
            this.previewMode = !this.previewMode;
            console.log(`Preview mode: ${this.previewMode ? 'ON' : 'OFF'}`);

            // Update status display
            this.updateStatusDisplay();

            return this.previewMode;
        }

        renderFrame(frameData) {
            if (!frameData || !frameData.frame_data) {
                this.renderNoAnimation();
                return;
            }

            // Update LED configuration if changed
            if (frameData.led_info) {
                if (this.stripCount !== frameData.led_info.strip_count ||
                    this.ledsPerStrip !== frameData.led_info.leds_per_strip) {
                    this.stripCount = frameData.led_info.strip_count;
                    this.ledsPerStrip = frameData.led_info.leds_per_strip;
                    this.totalLeds = frameData.led_info.total_leds;
                    this.setupCanvas();
                }
            }

            // Clear canvas
            this.ctx.fillStyle = '#000000';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            // Render LEDs
            const colors = frameData.frame_data;
            for (let strip = 0; strip < this.stripCount; strip++) {
                for (let led = 0; led < this.ledsPerStrip; led++) {
                    const pixelIndex = strip * this.ledsPerStrip + led;
                    if (pixelIndex < colors.length) {
                        const [r, g, b] = colors[pixelIndex];
                        this.renderLED(strip, led, r, g, b);
                    }
                }
            }

            // Update frame counter
            this.frameCount++;
            this.updateFPS();
        }

        renderLED(strip, led, r, g, b) {
            const x = strip * (this.actualLedSize + this.actualStripSpacing);
            const y = (this.ledsPerStrip - 1 - led) * (this.actualLedSize + this.actualLedSpacing);

            this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            this.ctx.fillRect(x, y, this.actualLedSize, this.actualLedSize);
        }

        renderNoAnimation() {
            // Clear canvas and show "no animation" state
            this.ctx.fillStyle = '#1a1a1a';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            // Draw grid pattern to show LED layout
            this.ctx.strokeStyle = '#333333';
            this.ctx.lineWidth = 0.5;

            for (let strip = 0; strip < this.stripCount; strip++) {
                for (let led = 0; led < Math.min(this.ledsPerStrip, 100); led += 10) {
                    const x = strip * (this.actualLedSize + this.actualStripSpacing);
                    const y = (this.ledsPerStrip - 1 - led) * (this.actualLedSize + this.actualLedSpacing);
                    this.ctx.strokeRect(x, y, this.actualLedSize, this.actualLedSize);
                }
            }
        }

        updateFPS() {
            this.fpsCounter++;
            const now = Date.now();
            if (now - this.lastFpsTime >= 1000) {
                this.fps = this.fpsCounter;
                this.fpsCounter = 0;
                this.lastFpsTime = now;

                // Update UI
                document.getElementById('rendererFPS').textContent = `${this.fps} FPS`;
                document.getElementById('rendererFrameCount').textContent = `${this.frameCount} frames`;
            }
        }

        async renderLoop() {
            if (!this.isRunning) return;

            if (this.fetchInFlight) {
                this.scheduleNextFrame();
                return;
            }

            this.fetchInFlight = true;
            let frameData = null;
            try {
                frameData = await this.fetchFrameData();
            } catch (error) {
                console.error('Error in render loop:', error);
            }
            this.fetchInFlight = false;

            if (frameData) {
                this.lastFrameData = frameData;
                this.renderFrame(frameData);
            } else if (this.lastFrameData) {
                this.renderFrame(this.lastFrameData);
            } else {
                this.renderNoAnimation();
            }

            // Update status
            this.updateStatusDisplay(frameData || this.lastFrameData);

            // Schedule next frame
            this.scheduleNextFrame();
        }

        scheduleNextFrame() {
            if (!this.isRunning) return;
            if (this.renderTimer) {
                clearTimeout(this.renderTimer);
            }
            this.renderTimer = setTimeout(() => this.renderLoop(), this.fetchIntervalMs);
        }

        updateStatusDisplay(frameData = null) {
            const statusEl = document.getElementById('rendererStatus');

            if (this.previewMode) {
                statusEl.textContent = `Preview: ${this.previewAnimation || 'None selected'}`;
                statusEl.className = 'text-primary'; // Blue for preview mode
            } else if (frameData && frameData.is_running) {
                statusEl.textContent = `Running: ${frameData.current_animation || 'Unknown'}`;
                statusEl.className = 'text-success'; // Green for running
            } else {
                statusEl.textContent = 'No animation';
                statusEl.className = 'text-muted'; // Gray for stopped
            }
        }

        startRendering() {
            if (this.isRunning) return;
            this.isRunning = true;
            this.scheduleNextFrame();
        }

        stopRendering() {
            this.isRunning = false;
            if (this.renderTimer) {
                clearTimeout(this.renderTimer);
                this.renderTimer = null;
            }
            this.fetchInFlight = false;
        }

        reset() {
            this.frameCount = 0;
            this.fps = 0;
            this.fpsCounter = 0;
            this.lastFpsTime = Date.now();
            this.lastFrameData = null;
            document.getElementById('rendererFrameCount').textContent = '0 frames';
            document.getElementById('rendererFPS').textContent = '0 FPS';
        }
    }

    // Global renderer & stats polling
    let animationRenderer = null;
    let statsPollTimer = null;
    let latestStatusJson = '';
    let controlSelectedAnimation = null;
    let controlParameterUpdateTimeout = null;
    let controlParameterStore = {};

    // Initialize renderer when page loads
    document.addEventListener('DOMContentLoaded', function() {
        animationRenderer = new LEDAnimationRenderer('ledCanvas');
        if (INITIAL_STATUS) {
            syncControlPanel(INITIAL_STATUS);
        }
        startStatsPolling();
    });

    // Renderer control functions
    function toggleRenderer() {
        const container = document.getElementById('rendererContainer');
        const button = document.getElementById('toggleRenderer');

        if (container.style.display === 'none') {
            container.style.display = 'block';
            button.innerHTML = '<i class="fas fa-eye"></i> Hide';
            if (animationRenderer) {
                animationRenderer.startRendering();
            }
        } else {
            container.style.display = 'none';
            button.innerHTML = '<i class="fas fa-eye-slash"></i> Show';
            if (animationRenderer) {
                animationRenderer.stopRendering();
            }
        }
    }

    function resetRenderer() {
        if (animationRenderer) {
            animationRenderer.reset();
        }
    }

    function togglePreviewMode() {
        if (animationRenderer) {
            const isPreviewMode = animationRenderer.togglePreviewMode();
            const button = document.getElementById('previewToggle');
            const buttonText = document.getElementById('previewToggleText');

            if (isPreviewMode) {
                button.className = 'btn btn-primary btn-sm';
                buttonText.textContent = 'Live Mode';
                if (controlSelectedAnimation) {
                    syncPreviewParameters(controlSelectedAnimation);
                }
            } else {
                button.className = 'btn btn-outline-primary btn-sm';
                buttonText.textContent = 'Preview Mode';
            }
        }
    }

    function previewAnimation(animationName) {
        if (animationRenderer) {
            // Enable preview mode if not already enabled
            if (!animationRenderer.previewMode) {
                togglePreviewMode();
            }

            // Set the animation to preview
            const params = controlParameterStore[animationName] || null;
            animationRenderer.setPreviewAnimation(animationName, params);
        }
    }

    // Handle animation card clicks with feedback
    function startAnimation(name, config = {}) {
        // Show loading state
        const cards = document.querySelectorAll('.animation-card');
        cards.forEach(card => card.style.opacity = '0.6');
        
        return fetch(`/api/start/${name}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(config)
        })
        .then(r => r.json())
        .then(result => {
            if (result.success) {
                showToast(`Started animation: ${name}`, 'success');
            } else {
                showToast(`Failed to start animation: ${name}`, 'error');
            }
            return result;
        })
        .catch(error => {
            showToast(`Error: ${error.message}`, 'error');
            return {success: false, error: error.message};
        })
        .finally(() => {
            cards.forEach(card => card.style.opacity = '1');
        });
    }

    function requestRandomHole() {
        fetch('/api/hole', {method: 'POST'})
            .then(r => r.json())
            .then(result => {
                if (result.success) {
                    if (typeof showToast === 'function') {
                        showToast('Punched a random hole', 'success');
                    }
                }
            })
            .catch(error => console.error('Failed to punch hole', error));
    }

    function startStatsPolling() {
        fetchSceneStats();
        if (statsPollTimer) {
            clearInterval(statsPollTimer);
        }
        statsPollTimer = setInterval(fetchSceneStats, 2000);
    }

    async function fetchSceneStats() {
        try {
            const response = await fetch('/api/status');
            if (!response.ok) return;
            const data = await response.json();
            latestStatusJson = JSON.stringify(data, null, 2);
            updateSceneStatsPanel(data);
            updateStatusJson(data);
            syncControlPanel(data);
        } catch (err) {
            console.error('Failed to fetch stats', err);
        }
    }

    function updateSceneStatsPanel(payload) {
        if (!payload) return;
        const stats = payload.animation_stats || payload.stats || {};
        safeSetText('statFill', stats.fill_ratio != null ? formatPercent(stats.fill_ratio) : '--');
        const expected = stats.expected_ratio != null ? formatPercent(stats.expected_ratio) : '--';
        safeSetText('statExpected', expected);
        safeSetText('statHole', stats.hole_active ? 'Yes' : 'No');
        const bubbleRise = stats.max_bubble_rise ? `${(stats.max_bubble_rise || 0).toFixed(1)}px` : '0px';
        const bubbleLabel = `${stats.bubble_count || 0} (${bubbleRise})`;
        safeSetText('statBubbles', bubbleLabel);
        safeSetText('statSpray', stats.spray_particle_count != null ? stats.spray_particle_count : '--');
        safeSetText('statSpawnAllowed', stats.spawn_allowed === false ? 'Paused' : 'Yes');
        const hashValue = payload.animation_hash || '';
        let shortHash = '--';
        if (hashValue) {
            shortHash = hashValue.length > 15 ? `${hashValue.slice(0, 15)}…` : hashValue;
        }
        safeSetText('statHash', shortHash);
        const hashEl = document.getElementById('statHash');
        if (hashEl) {
            hashEl.title = hashValue || 'No hash available';
        }
    }

    function updateStatusJson(payload) {
        const el = document.getElementById('statusJson');
        if (el) {
            el.textContent = latestStatusJson || JSON.stringify(payload, null, 2);
        }
    }

    function copyStatusJson() {
        if (!latestStatusJson) {
            showToast('No status data yet', 'info');
            return;
        }
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(latestStatusJson)
                .then(() => showToast('Status JSON copied', 'success'))
                .catch(err => {
                    console.error('Clipboard copy failed', err);
                    fallbackCopy(latestStatusJson);
                });
        } else {
            fallbackCopy(latestStatusJson);
        }
    }

    function fallbackCopy(text) {
        const textarea = document.createElement('textarea');
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand('copy');
        document.body.removeChild(textarea);
        showToast('Status JSON copied', 'success');
    }

    function safeSetText(id, value) {
        const el = document.getElementById(id);
        if (el) {
            el.textContent = value;
        }
    }

    function formatPercent(value) {
        return `${Math.round(value * 100)}%`;
    }

    function humanizeParamName(name) {
        return name.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    }

    function showControlPlaceholder(message, options = {}) {
        const placeholder = document.getElementById('controlParametersPlaceholder');
        const card = document.getElementById('controlParametersCard');
        if (options.clearControls) {
            const container = document.getElementById('controlParametersContainer');
            if (container) {
                container.innerHTML = '';
            }
        }
        if (placeholder) {
            placeholder.textContent = message;
            placeholder.style.display = 'block';
        }
        if (card) {
            card.style.display = 'none';
        }
    }

    function hideControlPlaceholder() {
        const placeholder = document.getElementById('controlParametersPlaceholder');
        const card = document.getElementById('controlParametersCard');
        if (placeholder) {
            placeholder.style.display = 'none';
        }
        if (card) {
            card.style.display = 'block';
        }
    }

    function syncControlPanel(status) {
        if (!status) return;
        const runningAnimation = status.is_running ? status.current_animation : null;
        if (!runningAnimation) {
            if (controlSelectedAnimation !== null) {
                controlSelectedAnimation = null;
                highlightControlSelection(null);
            }
            showControlPlaceholder('Start or select an animation to adjust its live controls.', {clearControls: true});
            return;
        }
        if (controlSelectedAnimation === runningAnimation) {
            return;
        }
        controlSelectedAnimation = runningAnimation;
        highlightControlSelection(runningAnimation);
        loadControlParameters(runningAnimation, {
            placeholderMessage: `Loading controls for ${humanizeParamName(runningAnimation)}...`
        });
    }

    function highlightControlSelection(name) {
        document.querySelectorAll('.control-animation-btn').forEach(btn => {
            const isActive = Boolean(name && btn.dataset.animation === name);
            btn.classList.toggle('btn-primary', isActive);
            btn.classList.toggle('btn-outline-primary', !isActive);
        });
    }

    function syncPreviewParameters(animationName) {
        if (!animationRenderer || !animationRenderer.previewMode || !animationName) {
            return;
        }
        const params = controlParameterStore[animationName] || null;
        if (animationRenderer.previewAnimation !== animationName) {
            animationRenderer.setPreviewAnimation(animationName, params);
        } else {
            animationRenderer.setPreviewParams(params);
        }
    }

    function selectControlAnimation(name, options = {}) {
        controlSelectedAnimation = name;
        highlightControlSelection(name);
        if (animationRenderer && animationRenderer.previewMode) {
            const params = controlParameterStore[name] || null;
            animationRenderer.setPreviewAnimation(name, params);
        }
        const { skipStart = false, placeholderMessage = null } = options;
        const message = placeholderMessage || (skipStart
            ? 'Loading controls...'
            : 'Starting animation and loading controls...');
        showControlPlaceholder(message, {clearControls: true});
        const startPromise = skipStart ? Promise.resolve({success: true}) : startAnimation(name);
        startPromise.then(result => {
            if (result.success) {
                loadControlParameters(name, {showPlaceholder: false});
            } else {
                controlSelectedAnimation = null;
                highlightControlSelection(null);
                showControlPlaceholder('Unable to load controls. Start the animation to try again.', {clearControls: true});
            }
        }).catch(error => {
            console.error('Failed to select animation', error);
            controlSelectedAnimation = null;
            highlightControlSelection(null);
            showControlPlaceholder('Unable to load controls right now.', {clearControls: true});
        });
    }

    function loadControlParameters(name, options = {}) {
        const { showPlaceholder = true, placeholderMessage = null } = options;
        if (showPlaceholder) {
            showControlPlaceholder(placeholderMessage || 'Loading controls...', {clearControls: true});
        }
        fetch(`/api/animations/${name}`)
            .then(r => r.json())
            .then(info => {
                if (info && info.parameters && Object.keys(info.parameters).length) {
                    renderControlParameterControls(info.parameters, info.current_params || {});
                    hideControlPlaceholder();
                } else {
                    showControlPlaceholder('This animation does not expose live controls.', {clearControls: true});
                }
            })
            .catch(error => {
                console.error('Failed to load controls', error);
                showControlPlaceholder('Failed to load controls. Please try again.', {clearControls: true});
            });
    }

    function handleRangeInput(name, value, type, mirrorInputId) {
        const mirror = document.getElementById(mirrorInputId);
        if (mirror) {
            mirror.value = value;
        }
        updateControlParameter(name, value, type);
    }

    function handleNumberInput(name, value, type, mirrorSliderId) {
        if (value === '' || value === null) {
            return;
        }
        const slider = document.getElementById(mirrorSliderId);
        if (slider) {
            slider.value = value;
        }
        updateControlParameter(name, value, type);
    }

    function renderControlParameterControls(schema, currentParams) {
        const container = document.getElementById('controlParametersContainer');
        if (!container) return;
        container.innerHTML = '';
        const parameterSnapshot = {};

        Object.entries(schema).forEach(([paramName, paramInfo]) => {
            const currentValue = currentParams[paramName] ?? paramInfo.default;
            parameterSnapshot[paramName] = currentValue;
            const prettyName = humanizeParamName(paramName);
            const rangeText = (paramInfo.min !== undefined && paramInfo.max !== undefined)
                ? `Range: ${paramInfo.min} – ${paramInfo.max} (default ${paramInfo.default})`
                : `Default: ${paramInfo.default ?? '--'}`;
            const controlDiv = document.createElement('div');
            controlDiv.className = 'parameter-control mb-3';
            const inputId = `control-${paramName}`;
            const numberInputId = `${inputId}-value`;
            let controlHtml = `
                <label class="form-label mb-1">
                    <strong>${prettyName}</strong>
                    <small class="text-muted d-block">${paramInfo.description}</small>
                    <small class="text-muted">${rangeText}</small>
                </label>
            `;
            if (paramInfo.type === 'float' || paramInfo.type === 'int') {
                const step = paramInfo.type === 'float' ? '0.1' : '1';
                controlHtml += `
                    <div class="row align-items-center">
                        <div class="col-8">
                            <input type="range" class="form-range"
                                   id="${inputId}"
                                   min="${paramInfo.min}"
                                   max="${paramInfo.max}"
                                   step="${step}"
                                   value="${currentValue}"
                                   oninput="handleRangeInput('${paramName}', this.value, '${paramInfo.type}', '${numberInputId}')">
                        </div>
                        <div class="col-4">
                            <input type="number" class="form-control form-control-sm"
                                   value="${currentValue}"
                                   min="${paramInfo.min}"
                                   max="${paramInfo.max}"
                                   step="${step}"
                                   id="${numberInputId}"
                                   oninput="handleNumberInput('${paramName}', this.value, '${paramInfo.type}', '${inputId}')">
                        </div>
                    </div>
                `;
            } else if (paramInfo.type === 'bool') {
                controlHtml += `
                    <div class="form-check form-switch">
                        <input class="form-check-input" type="checkbox" id="${inputId}"
                               ${currentValue ? 'checked' : ''}
                               onchange="updateControlParameter('${paramName}', this.checked, 'bool')">
                        <label class="form-check-label" for="${inputId}">Enable</label>
                    </div>
                `;
            } else {
                controlHtml += `
                    <input type="text" class="form-control"
                           id="${inputId}"
                           value="${currentValue}"
                           onchange="updateControlParameter('${paramName}', this.value, 'str')">
                `;
            }
            controlDiv.innerHTML = controlHtml;
            container.appendChild(controlDiv);
        });

        if (controlSelectedAnimation) {
            controlParameterStore[controlSelectedAnimation] = parameterSnapshot;
            syncPreviewParameters(controlSelectedAnimation);
        }
    }

    function updateControlParameter(name, value, type) {
        let convertedValue = value;
        if (type === 'int') {
            convertedValue = parseInt(value, 10);
        } else if (type === 'float') {
            convertedValue = parseFloat(value);
        } else if (type === 'bool') {
            if (typeof value === 'string') {
                convertedValue = value === 'true' || value === '1';
            } else {
                convertedValue = Boolean(value);
            }
        }

        if ((type === 'int' || type === 'float') && Number.isNaN(convertedValue)) {
            return;
        }

        if (controlParameterUpdateTimeout) {
            clearTimeout(controlParameterUpdateTimeout);
        }

        if (controlSelectedAnimation) {
            if (!controlParameterStore[controlSelectedAnimation]) {
                controlParameterStore[controlSelectedAnimation] = {};
            }
            controlParameterStore[controlSelectedAnimation][name] = convertedValue;
            if (animationRenderer &&
                animationRenderer.previewMode &&
                animationRenderer.previewAnimation === controlSelectedAnimation) {
                animationRenderer.setPreviewParams(controlParameterStore[controlSelectedAnimation]);
            }
        }

        controlParameterUpdateTimeout = setTimeout(() => {
            const params = {};
            params[name] = convertedValue;
            updateParameters(params).then(result => {
                if (!result.success) {
                    console.error('Failed to update parameter:', name);
                }
            });
        }, 120);
    }
    
    function showToast(message, type = 'info') {
        // Simple toast notification
        const toast = document.createElement('div');
        toast.className = `alert alert-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'info'} position-fixed`;
        toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
        toast.innerHTML = `${message} <button type="button" class="btn-close" onclick="this.parentElement.remove()"></button>`;
        document.body.appendChild(toast);
        
        // Auto-remove after 3 seconds
        setTimeout(() => toast.remove(), 3000);
    }
</script>
{% endblock %}
