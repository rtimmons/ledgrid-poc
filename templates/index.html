{% extends "base.html" %}

{% block title %}LED Grid Dashboard{% endblock %}

{% block content %}
<!-- Animation Renderer -->
<div class="row mb-4">
    <div class="col-lg-8 mb-3 mb-lg-0">
        <div class="card h-100">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5><i class="fas fa-tv"></i> Live Animation Preview</h5>
                <div class="btn-group btn-group-sm" role="group">
                    <button type="button" class="btn btn-outline-secondary" id="toggleRenderer" onclick="toggleRenderer()">
                        <i class="fas fa-eye"></i> Hide
                    </button>
                    <button type="button" class="btn btn-outline-secondary" onclick="resetRenderer()">
                        <i class="fas fa-sync"></i> Reset
                    </button>
                    <button type="button" class="btn btn-outline-primary" id="previewToggle" onclick="togglePreviewMode()">
                        <i class="fas fa-search"></i> <span id="previewToggleText">Preview Mode</span>
                    </button>
                </div>
            </div>
            <div class="card-body" id="rendererContainer">
                <div id="animationRenderer" class="text-center">
                    <canvas id="ledCanvas" width="900" height="900" class="led-preview" style="border: 1px solid #ddd; border-radius: 8px; max-width: 100%; cursor: pointer;"></canvas>
                    <div class="mt-2">
                        <small class="text-muted d-block">
                            Canvas rotated to match the physical panel. Click anywhere to punch a random hole during the live scene.
                        </small>
                        <small class="text-muted">
                            <span id="rendererStatus">Waiting for animation...</span> |
                            <span id="rendererFPS">0 FPS</span> |
                            <span id="rendererFrameCount">0 frames</span>
                        </small>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="col-lg-4">
        <div class="card mb-3">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0"><i class="fas fa-tint"></i> Scene Controls & Stats</h5>
                <button class="btn btn-sm btn-outline-danger" onclick="requestRandomHole()">
                    <i class="fas fa-bolt"></i> Punch Hole
                </button>
            </div>
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center border-bottom pb-2 mb-2">
                    <span>Fill Level</span>
                    <strong id="statFill">--</strong>
                </div>
                <div class="d-flex justify-content-between align-items-center border-bottom pb-2 mb-2">
                    <span>On-Schedule</span>
                    <strong id="statExpected">--</strong>
                </div>
                <div class="d-flex justify-content-between align-items-center border-bottom pb-2 mb-2">
                    <span>Hole Active</span>
                    <strong id="statHole">--</strong>
                </div>
                <div class="d-flex justify-content-between align-items-center border-bottom pb-2 mb-2">
                    <span>Bubbles (rise)</span>
                    <strong id="statBubbles">--</strong>
                </div>
                <div class="d-flex justify-content-between align-items-center border-bottom pb-2 mb-2">
                    <span>Spray Particles</span>
                    <strong id="statSpray">--</strong>
                </div>
                <div class="d-flex justify-content-between align-items-center">
                    <span>Spawn Allowed</span>
                    <strong id="statSpawnAllowed">--</strong>
                </div>
                <small class="text-muted d-block mt-2">
                    Stats update live from <code>/api/stats</code> so hardware and simulator stay in sync.
                </small>
            </div>
        </div>
        <div class="card">
            <div class="card-header">
                <h5><i class="fas fa-info-circle"></i> System Status</h5>
            </div>
            <div class="card-body">
                <div class="mb-3">
                    <strong>Animation Status:</strong><br>
                    <span class="status-indicator {{ 'status-running' if status.is_running else 'status-stopped' }}"></span>
                    <span class="status-text">
                        {% if status.is_running %}
                            Running: {{ status.current_animation }}
                        {% else %}
                            Stopped
                        {% endif %}
                    </span>
                </div>
                
                <div class="mb-3">
                    <strong>Performance:</strong><br>
                    <span class="fps-display">{{ "%.1f"|format(status.actual_fps) }} FPS</span>
                    <small class="text-muted">(Target: {{ status.target_fps }} FPS)</small>
                </div>
                
                <div class="mb-3">
                    <strong>LED Configuration:</strong><br>
                    {{ status.led_info.strip_count }} strips Ã— {{ status.led_info.leds_per_strip }} LEDs<br>
                    <small class="text-muted">Total: {{ status.led_info.total_leds }} LEDs</small>
                </div>
                
                {% if status.is_running %}
                <div class="mb-3">
                    <strong>Runtime:</strong><br>
                    {{ "%.1f"|format(status.uptime) }}s
                    <small class="text-muted">({{ status.frame_count }} frames)</small>
                </div>
                {% endif %}
                
                {% if status.is_running and status.animation_info %}
                <div class="mb-3">
                    <strong>{{ status.animation_info.name }}</strong><br>
                    <small class="text-muted">{{ status.animation_info.description }}</small>
                </div>
                {% endif %}
                
                <div class="d-grid gap-2">
                    {% if status.is_running %}
                    <button class="btn btn-danger" onclick="stopAnimation()">
                        <i class="fas fa-stop"></i> Stop Animation
                    </button>
                    {% endif %}
                    
                    <button class="btn btn-outline-secondary" onclick="refreshPlugins()">
                        <i class="fas fa-sync"></i> Refresh Plugins
                    </button>
                    <a href="{{ url_for('control_page') }}" class="btn btn-outline-primary">
                        <i class="fas fa-sliders-h"></i> Control Panel
                    </a>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="row">
    <div class="col-12">
        <h2><i class="fas fa-palette"></i> Available Animations</h2>
        
        <div class="row">
            {% for animation in animations %}
            <div class="col-md-6 mb-3">
                <div class="card animation-card h-100">
                    <div class="card-body">
                        <h5 class="card-title">
                            <i class="fas fa-play-circle text-primary"></i>
                            {{ animation.name }}
                        </h5>
                        <p class="card-text">{{ animation.description }}</p>
                        <small class="text-muted">
                            <i class="fas fa-user"></i> {{ animation.author }}
                            <span class="ms-2"><i class="fas fa-tag"></i> v{{ animation.version }}</span>
                        </small>
                        <div class="mt-3 d-flex gap-2">
                            <button class="btn btn-outline-primary btn-sm" onclick="previewAnimation('{{ animation.plugin_name }}')">
                                <i class="fas fa-eye"></i> Preview
                            </button>
                            <button class="btn btn-primary btn-sm" onclick="startAnimation('{{ animation.plugin_name }}')">
                                <i class="fas fa-play"></i> Start
                            </button>
                        </div>
                    </div>
                </div>
            </div>
            {% endfor %}
        </div>
        
        {% if not animations %}
        <div class="alert alert-warning">
            <i class="fas fa-exclamation-triangle"></i>
            No animations found. Upload some animation plugins to get started!
        </div>
        {% endif %}
    </div>
</div>

<div class="row mt-4">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h5><i class="fas fa-question-circle"></i> Quick Start</h5>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-4">
                        <h6><i class="fas fa-play"></i> Start Animation</h6>
                        <p>Click any animation card above to start it immediately with default settings.</p>
                    </div>
                    <div class="col-md-4">
                        <h6><i class="fas fa-sliders-h"></i> Adjust Parameters</h6>
                        <p>Use the <a href="{{ url_for('control_page') }}">Control Panel</a> to fine-tune animation parameters in real-time.</p>
                    </div>
                    <div class="col-md-4">
                        <h6><i class="fas fa-upload"></i> Upload Animations</h6>
                        <p>Create custom animations and <a href="{{ url_for('upload_page') }}">upload them</a> as Python plugins.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    const INITIAL_STRIP_COUNT = {{ status.led_info.strip_count | default(8) }};
    const INITIAL_LEDS_PER_STRIP = {{ status.led_info.leds_per_strip | default(140) }};

    // Animation Renderer
    class LEDAnimationRenderer {
        constructor(canvasId) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            this.isRunning = false;
            this.frameCount = 0;
            this.lastFrameTime = 0;
            this.fps = 0;

            // Preview mode settings
            this.previewMode = false;
            this.previewAnimation = null;
            this.fpsCounter = 0;
            this.lastFpsTime = Date.now();
            this.fetchIntervalMs = 150;   // Limit backend polling to ~6-7 FPS
            this.renderTimer = null;
            this.fetchInFlight = false;
            this.lastFrameData = null;

            // LED configuration - will be updated from server
            this.stripCount = INITIAL_STRIP_COUNT;
            this.ledsPerStrip = INITIAL_LEDS_PER_STRIP;
            this.totalLeds = this.stripCount * this.ledsPerStrip;

            // Rendering configuration
            this.ledSize = 6;
            this.ledSpacing = 0.5;
            this.stripSpacing = 1;
            this.canvas.addEventListener('click', () => requestRandomHole());

            this.setupCanvas();
            this.startRendering();
        }

        setupCanvas() {
            // Calculate canvas dimensions based on rotated LED layout (strips run horizontally)
            const totalWidth = this.stripCount * (this.ledSize + this.stripSpacing);
            const totalHeight = this.ledsPerStrip * (this.ledSize + this.ledSpacing);

            this.canvas.width = Math.min(totalWidth * 6, 900);
            this.canvas.height = Math.min(totalHeight * 4, 900);

            // Scale LEDs to fit canvas
            this.scaleX = this.canvas.width / totalWidth;
            this.scaleY = this.canvas.height / totalHeight;
            this.scale = Math.min(this.scaleX, this.scaleY);

            this.actualLedSize = Math.max(1, this.ledSize * this.scale);
            this.actualLedSpacing = this.ledSpacing * this.scale;
            this.actualStripSpacing = this.stripSpacing * this.scale;
        }

        async fetchFrameData() {
            try {
                if (this.previewMode && this.previewAnimation) {
                    // In preview mode, fetch preview data for specific animation
                    const response = await fetch(`/api/preview/${this.previewAnimation}`);
                    const data = await response.json();
                    return data;
                } else {
                    // Normal mode - fetch current running animation
                    const response = await fetch('/api/frame');
                    const data = await response.json();
                    return data;
                }
            } catch (error) {
                console.error('Error fetching frame data:', error);
                return null;
            }
        }

        setPreviewAnimation(animationName) {
            this.previewAnimation = animationName;
            console.log(`Preview animation set to: ${animationName}`);
        }

        togglePreviewMode() {
            this.previewMode = !this.previewMode;
            console.log(`Preview mode: ${this.previewMode ? 'ON' : 'OFF'}`);

            // Update status display
            this.updateStatusDisplay();

            return this.previewMode;
        }

        renderFrame(frameData) {
            if (!frameData || !frameData.frame_data) {
                this.renderNoAnimation();
                return;
            }

            // Update LED configuration if changed
            if (frameData.led_info) {
                if (this.stripCount !== frameData.led_info.strip_count ||
                    this.ledsPerStrip !== frameData.led_info.leds_per_strip) {
                    this.stripCount = frameData.led_info.strip_count;
                    this.ledsPerStrip = frameData.led_info.leds_per_strip;
                    this.totalLeds = frameData.led_info.total_leds;
                    this.setupCanvas();
                }
            }

            // Clear canvas
            this.ctx.fillStyle = '#000000';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            // Render LEDs
            const colors = frameData.frame_data;
            for (let strip = 0; strip < this.stripCount; strip++) {
                for (let led = 0; led < this.ledsPerStrip; led++) {
                    const pixelIndex = strip * this.ledsPerStrip + led;
                    if (pixelIndex < colors.length) {
                        const [r, g, b] = colors[pixelIndex];
                        this.renderLED(strip, led, r, g, b);
                    }
                }
            }

            // Update frame counter
            this.frameCount++;
            this.updateFPS();
        }

        renderLED(strip, led, r, g, b) {
            const x = strip * (this.actualLedSize + this.actualStripSpacing);
            const y = (this.ledsPerStrip - 1 - led) * (this.actualLedSize + this.actualLedSpacing);

            this.ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
            this.ctx.fillRect(x, y, this.actualLedSize, this.actualLedSize);
        }

        renderNoAnimation() {
            // Clear canvas and show "no animation" state
            this.ctx.fillStyle = '#1a1a1a';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            // Draw grid pattern to show LED layout
            this.ctx.strokeStyle = '#333333';
            this.ctx.lineWidth = 0.5;

            for (let strip = 0; strip < this.stripCount; strip++) {
                for (let led = 0; led < Math.min(this.ledsPerStrip, 100); led += 10) {
                    const x = strip * (this.actualLedSize + this.actualStripSpacing);
                    const y = (this.ledsPerStrip - 1 - led) * (this.actualLedSize + this.actualLedSpacing);
                    this.ctx.strokeRect(x, y, this.actualLedSize, this.actualLedSize);
                }
            }
        }

        updateFPS() {
            this.fpsCounter++;
            const now = Date.now();
            if (now - this.lastFpsTime >= 1000) {
                this.fps = this.fpsCounter;
                this.fpsCounter = 0;
                this.lastFpsTime = now;

                // Update UI
                document.getElementById('rendererFPS').textContent = `${this.fps} FPS`;
                document.getElementById('rendererFrameCount').textContent = `${this.frameCount} frames`;
            }
        }

        async renderLoop() {
            if (!this.isRunning) return;

            if (this.fetchInFlight) {
                this.scheduleNextFrame();
                return;
            }

            this.fetchInFlight = true;
            let frameData = null;
            try {
                frameData = await this.fetchFrameData();
            } catch (error) {
                console.error('Error in render loop:', error);
            }
            this.fetchInFlight = false;

            if (frameData) {
                this.lastFrameData = frameData;
                this.renderFrame(frameData);
            } else if (this.lastFrameData) {
                this.renderFrame(this.lastFrameData);
            } else {
                this.renderNoAnimation();
            }

            // Update status
            this.updateStatusDisplay(frameData || this.lastFrameData);

            // Schedule next frame
            this.scheduleNextFrame();
        }

        scheduleNextFrame() {
            if (!this.isRunning) return;
            if (this.renderTimer) {
                clearTimeout(this.renderTimer);
            }
            this.renderTimer = setTimeout(() => this.renderLoop(), this.fetchIntervalMs);
        }

        updateStatusDisplay(frameData = null) {
            const statusEl = document.getElementById('rendererStatus');

            if (this.previewMode) {
                statusEl.textContent = `Preview: ${this.previewAnimation || 'None selected'}`;
                statusEl.className = 'text-primary'; // Blue for preview mode
            } else if (frameData && frameData.is_running) {
                statusEl.textContent = `Running: ${frameData.current_animation || 'Unknown'}`;
                statusEl.className = 'text-success'; // Green for running
            } else {
                statusEl.textContent = 'No animation';
                statusEl.className = 'text-muted'; // Gray for stopped
            }
        }

        startRendering() {
            if (this.isRunning) return;
            this.isRunning = true;
            this.scheduleNextFrame();
        }

        stopRendering() {
            this.isRunning = false;
            if (this.renderTimer) {
                clearTimeout(this.renderTimer);
                this.renderTimer = null;
            }
            this.fetchInFlight = false;
        }

        reset() {
            this.frameCount = 0;
            this.fps = 0;
            this.fpsCounter = 0;
            this.lastFpsTime = Date.now();
            this.lastFrameData = null;
            document.getElementById('rendererFrameCount').textContent = '0 frames';
            document.getElementById('rendererFPS').textContent = '0 FPS';
        }
    }

    // Global renderer & stats polling
    let animationRenderer = null;
    let statsPollTimer = null;

    // Initialize renderer when page loads
    document.addEventListener('DOMContentLoaded', function() {
        animationRenderer = new LEDAnimationRenderer('ledCanvas');
        startStatsPolling();
    });

    // Renderer control functions
    function toggleRenderer() {
        const container = document.getElementById('rendererContainer');
        const button = document.getElementById('toggleRenderer');

        if (container.style.display === 'none') {
            container.style.display = 'block';
            button.innerHTML = '<i class="fas fa-eye"></i> Hide';
            if (animationRenderer) {
                animationRenderer.startRendering();
            }
        } else {
            container.style.display = 'none';
            button.innerHTML = '<i class="fas fa-eye-slash"></i> Show';
            if (animationRenderer) {
                animationRenderer.stopRendering();
            }
        }
    }

    function resetRenderer() {
        if (animationRenderer) {
            animationRenderer.reset();
        }
    }

    function togglePreviewMode() {
        if (animationRenderer) {
            const isPreviewMode = animationRenderer.togglePreviewMode();
            const button = document.getElementById('previewToggle');
            const buttonText = document.getElementById('previewToggleText');

            if (isPreviewMode) {
                button.className = 'btn btn-primary btn-sm';
                buttonText.textContent = 'Live Mode';
            } else {
                button.className = 'btn btn-outline-primary btn-sm';
                buttonText.textContent = 'Preview Mode';
            }
        }
    }

    function previewAnimation(animationName) {
        if (animationRenderer) {
            // Enable preview mode if not already enabled
            if (!animationRenderer.previewMode) {
                togglePreviewMode();
            }

            // Set the animation to preview
            animationRenderer.setPreviewAnimation(animationName);
        }
    }

    // Handle animation card clicks with feedback
    function startAnimation(name, config = {}) {
        // Show loading state
        const cards = document.querySelectorAll('.animation-card');
        cards.forEach(card => card.style.opacity = '0.6');
        
        fetch(`/api/start/${name}`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(config)
        })
        .then(r => r.json())
        .then(result => {
            if (result.success) {
                // Show success feedback
                showToast(`Started animation: ${name}`, 'success');
            } else {
                showToast(`Failed to start animation: ${name}`, 'error');
            }
        })
        .catch(error => {
            showToast(`Error: ${error.message}`, 'error');
        })
        .finally(() => {
            // Restore card opacity
            cards.forEach(card => card.style.opacity = '1');
        });
    }

    function requestRandomHole() {
        fetch('/api/hole', {method: 'POST'})
            .then(r => r.json())
            .then(result => {
                if (result.success) {
                    if (typeof showToast === 'function') {
                        showToast('Punched a random hole', 'success');
                    }
                }
            })
            .catch(error => console.error('Failed to punch hole', error));
    }

    function startStatsPolling() {
        fetchSceneStats();
        if (statsPollTimer) {
            clearInterval(statsPollTimer);
        }
        statsPollTimer = setInterval(fetchSceneStats, 2000);
    }

    async function fetchSceneStats() {
        try {
            const response = await fetch('/api/stats');
            if (!response.ok) return;
            const data = await response.json();
            updateSceneStatsPanel(data);
        } catch (err) {
            console.error('Failed to fetch stats', err);
        }
    }

    function updateSceneStatsPanel(payload) {
        if (!payload) return;
        const stats = payload.stats || {};
        safeSetText('statFill', stats.fill_ratio != null ? formatPercent(stats.fill_ratio) : '--');
        const expected = stats.expected_ratio != null ? formatPercent(stats.expected_ratio) : '--';
        safeSetText('statExpected', expected);
        safeSetText('statHole', stats.hole_active ? 'Yes' : 'No');
        const bubbleRise = stats.max_bubble_rise ? `${(stats.max_bubble_rise || 0).toFixed(1)}px` : '0px';
        const bubbleLabel = `${stats.bubble_count || 0} (${bubbleRise})`;
        safeSetText('statBubbles', bubbleLabel);
        safeSetText('statSpray', stats.spray_particle_count != null ? stats.spray_particle_count : '--');
        safeSetText('statSpawnAllowed', stats.spawn_allowed === false ? 'Paused' : 'Yes');
    }

    function safeSetText(id, value) {
        const el = document.getElementById(id);
        if (el) {
            el.textContent = value;
        }
    }

    function formatPercent(value) {
        return `${Math.round(value * 100)}%`;
    }
    
    function showToast(message, type = 'info') {
        // Simple toast notification
        const toast = document.createElement('div');
        toast.className = `alert alert-${type === 'error' ? 'danger' : type === 'success' ? 'success' : 'info'} position-fixed`;
        toast.style.cssText = 'top: 20px; right: 20px; z-index: 9999; min-width: 300px;';
        toast.innerHTML = `${message} <button type="button" class="btn-close" onclick="this.parentElement.remove()"></button>`;
        document.body.appendChild(toast);
        
        // Auto-remove after 3 seconds
        setTimeout(() => toast.remove(), 3000);
    }
</script>
{% endblock %}
